package com.examplefg.malwarechecker.Model;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;

import androidx.annotation.NonNull;
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.Ignore;
import androidx.room.PrimaryKey;

import java.io.ByteArrayOutputStream;
import java.util.ArrayList;

@Entity(tableName = "Appli")
public class Appli {

    @PrimaryKey
    @NonNull
    private String packageName;

    private String label;

    @Ignore
    private Drawable icone;

    @ColumnInfo(typeAffinity = ColumnInfo.BLOB)
    private byte[] iconeByte; //pour sauvegarder l'icone dans la base de donn√©es

    @Ignore
    private ArrayList<String> permissionsPropres;

    private String signature;

    private boolean Malware;

    public Appli(String label,String packageName)
    {
        this.label = label;
        this.packageName = packageName;
    }

    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public String getPackageName() {
        return packageName;
    }

    public void setPackageName(String packageName) {
        this.packageName = packageName;
    }

    public Drawable getIcone() {
        return icone;
    }

    public void setIcone(Drawable icone) {
        this.icone = icone;
    }

    public boolean isMalware()
    {
        return this.Malware;
    }

    public void setMalware(boolean malware)
    {
        this.Malware = malware;
    }

    public ArrayList<String> getPermissionsPropres() {
        return permissionsPropres;
    }

    public void setPermissionsPropres(ArrayList<String> permissionsPropres) {
        this.permissionsPropres = permissionsPropres;
    }

    public String getSignature() {
        return signature;
    }

    public void setSignature(String signature) {
        this.signature = signature;
    }

    public byte[] getIconeByte() {
        return iconeByte;
    }

    public void setIconeByte(byte[] iconeByte) {
        this.iconeByte = iconeByte;
    }

    //convertir le drawable en byte[] pour sauvegarder dans la BDD (from sof)
    public void drawableToByte()
    {
        Bitmap bitmap = getBitmapFromDrawable(this.icone);
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream);
        this.iconeByte = stream.toByteArray();
    }

    //convertir le byte[] en drawable apres lecture pour affichage
    public void byteToDrawable(Context context)
    {
        this.icone = new BitmapDrawable(context.getResources(),
                BitmapFactory.decodeByteArray(this.iconeByte, 0, this.iconeByte.length));
    }

    static private Bitmap getBitmapFromDrawable(@NonNull Drawable drawable) {
        final Bitmap bmp = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
        final Canvas canvas = new Canvas(bmp);
        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
        drawable.draw(canvas);
        return bmp;
    }

}
