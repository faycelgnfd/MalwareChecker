package com.examplefg.malwarechecker.Control.Utils;

import com.examplefg.malwarechecker.Model.Appli;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;

//singleton pour pour construire les signatures des applications à scanner
public class SignatureBuilder {

    private static SignatureBuilder instance = null;
    private static ArrayList<String> permissionsTest; //liste des permissions caractéristiques

    private SignatureBuilder()
    {
        initialiseFeaturePermissions();
    }

    //initialiser les caractéristiques pour tester les applications
    private void initialiseFeaturePermissions() {
        permissionsTest = new ArrayList<String>();
        permissionsTest.addAll(Arrays.asList("android.permission.BLUETOOTH", "android.permission.CAMERA",
                "android.permission.CHANGE_WIFI_STATE",
                "android.permission.DEVICE_POWER",
                "android.permission.DISABLE_KEYGUARD", "android.permission.GET_TASKS",
                "android.permission.INSTALL_PACKAGES", "android.permission.INTERNET",
                "android.permission.MODIFY_AUDIO_SETTINGS",
                "android.permission.MOUNT_UNMOUNT_FILESYSTEMS",
                "android.permission.READ_CALENDAR", "android.permission.READ_CALL_LOG",
                "android.permission.READ_PHONE_STATE", "android.permission.READ_SMS",
                "android.permission.RECEIVE_BOOT_COMPLETED",
                "android.permission.SEND_SMS",
                "android.permission.SET_PREFERRED_APPLICATIONS",
                "android.permission.USE_CREDENTIALS", "android.permission.WAKE_LOCK",
                "android.permission.WRITE_APN_SETTINGS",
                "android.permission.WRITE_SETTINGS", "android.permission.WRITE_SMS",
                "com.android.browser.permission.READ_HISTORY_BOOKMARKS"));
    }

    //construit le vecteur pour la prediction de l'observation (l'application)
    public static String buildAppSignature(Appli app) {
        StringBuffer appSignature = new StringBuffer();

        for (String permission : permissionsTest) {
            //si l'application analysée contient la permission caractéristique
            if (app.getPermissionsPropres().contains(permission)) {
                appSignature.append("1,");
            } else {
                appSignature.append("0,");
            }
        }

        return appSignature.toString().substring(0, appSignature.toString().length() - 1);
    }

    public static SignatureBuilder getInstance()
    {
        if(instance==null)
        {
            instance = new SignatureBuilder();
        }

        return instance;
    }

    public static ArrayList<String> extractPermissions ( String s) {

        ArrayList<String> l = new ArrayList<String>();

        String temp = "";


        int i=0;

        while(i<s.length())
        {
            if(s.charAt(i)=='a')
            {
                String nv = s.substring(i, i+19);
                int j = i+19;
                //System.out.println("string extracted nv is : "+nv);

                if(nv.equals("android.permission."))
                {
                    temp = temp +nv;
                    while(  (  j<s.length()) && (isMaj(s.charAt(j))) )
                    {
                        temp = temp + s.charAt(j);
                        //System.out.println("temp : "+temp);
                        j++;
                    }
                    //System.out.println("\ntemp a l sortie de j : "+ temp);

                    i=i+temp.length();
                    l.add(temp);
                    temp ="";
                }
                else
                {
                    i++;
                }
            }
            else if (s.charAt(i)=='c') {
                String nv = s.substring(i, i + 31);
                int j = i + 31;
                //System.out.println("string extracted nv is : "+nv);

                if (nv.equals("com.android.browser.permission."))
                {
                    temp = temp + nv;
                    while ((j < s.length()) && (isMaj(s.charAt(j)))) {
                        temp = temp + s.charAt(j);
                        //System.out.println("temp : "+temp);
                        j++;
                    }
                    //System.out.println("\ntemp a l sortie de j : "+ temp);

                    i = i + temp.length();
                    l.add(temp);
                    temp = "";

                }
                else
                {
                    i++;
                }

            }
            else
            {
                i++;
            }

        }

        return l;
    }

    public static boolean isMaj ( char c) {

        if(  ( c >= 'A' && c<= 'Z' ) || (c=='_') )
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    public static String extraxtExtensionFromPath(String path) {

        String extension = path.substring(path.lastIndexOf("."));
        return extension;
    }

    public static String extraxtAppNameFromPath(String path) {

        String appName = path.substring(path.lastIndexOf("/"));
        String name = appName.substring(1,appName.lastIndexOf("."));

        return name;
    }

    // Input stream to bytes
    public static byte[] isToBytes(InputStream is) throws IOException {

        ByteArrayOutputStream buffer = new ByteArrayOutputStream();

        int nRead;
        byte[] data = new byte[16384];

        while ((nRead = is.read(data, 0, data.length)) != -1) {
            buffer.write(data, 0, nRead);
        }

        return buffer.toByteArray();
    }
}
