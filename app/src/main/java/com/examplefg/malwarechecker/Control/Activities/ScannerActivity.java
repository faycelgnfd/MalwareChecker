package com.examplefg.malwarechecker.Control.Activities;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.app.Dialog;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.SearchView;
import android.widget.TextView;
import android.widget.Toast;

import com.bumptech.glide.Glide;
import com.examplefg.malwarechecker.Control.ScannerAdapter;
import com.examplefg.malwarechecker.Control.Utils.ItemClickSupport;
import com.examplefg.malwarechecker.Control.Utils.PredictionAsyncTask;
import com.examplefg.malwarechecker.Control.Utils.SignatureBuilder;
import com.examplefg.malwarechecker.Database.MalwareCheckerDatabase;
import com.examplefg.malwarechecker.Model.Appli;
import com.examplefg.malwarechecker.R;
import com.examplefg.malwarechecker.api.firestore.ApplisHelper;
import com.google.android.gms.tasks.OnFailureListener;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import butterknife.BindView;
import butterknife.ButterKnife;

public class ScannerActivity extends AppCompatActivity implements PredictionAsyncTask.Listeners {

    @BindView(R.id.activity_scanner_recyclerView)
    RecyclerView mRecyclerView;
    private ScannerAdapter adapter;
    private Appli appToScan;
    private PackageManager packageManager;
    private String appSignature; //vecteur des caractéristique pour la prediction
    private final String PREDICTION_API_URL = "https://malware-prediction-api.herokuapp.com/predict";
    private final String PREF_FILE_NAME = "StatFile";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_scanner);

        //instancier le package manager
        this.packageManager = this.getPackageManager();

        //relier les vues
        ButterKnife.bind(this);

        //activer la Toolbar
        this.configureToolbar();

        //configurer et afficher le RecyclerView
        this.configureRecyclerView();

        //configurer les cliques sur le RecyclerView
        this.configureOnClickRecyclerView();

    }

    //permet de configuer la Toolbar pour et l'afficher pour cette activity
    private void configureToolbar() {
        Toolbar toolbar = (Toolbar) findViewById(R.id.appToolbar);
        toolbar.setTitle("Scanner");
        setSupportActionBar(toolbar);
    }

    //avant l'execution de la tache (requete reseau)
    @Override
    public void onPreExecute() {
        Toast.makeText(ScannerActivity.this, "Wait For It", Toast.LENGTH_SHORT).show();
    }

    //après l'exécution de la tache
    @Override
    public void onPostExecute(String success) {
        //recuperation de la prediction de du modèle
        int prediction = Character.getNumericValue(success.charAt(1));

        //recuperer le fichier de preferences (statistics)
        SharedPreferences stats = getSharedPreferences(PREF_FILE_NAME, MODE_PRIVATE);

        //mettre à jour le nombre d'application scannées
        stats.edit().putInt("application_scanned", stats.getInt("application_scanned", 0) + 1);

        //si l'application n'est pas dangereuse
        if (prediction == 0) {
            appToScan.setMalware(false);
           // Toast.makeText(ScannerActivity.this, "Goodware", Toast.LENGTH_LONG).show();
            System.out.println("Goodware");
            stats.edit().putInt("goodwares", stats.getInt("goodwares", 0) + 1).apply();
        } else {
            appToScan.setMalware(true);
           // Toast.makeText(ScannerActivity.this, "Malware", Toast.LENGTH_LONG).show();
            System.out.println("Malware");
            stats.edit().putInt("malwares", stats.getInt("malwares", 0) + 1).apply();
        }

        //afficher le resultat sous forme de dialog
        showPopup(ScannerActivity.this,appToScan);

        //incrementer stats
        stats.edit().putInt("application_scanned", stats.getInt("application_scanned", 0) + 1).apply();

        //ajouter l'appli scannée à la base de données
        sauvegarderAppliBdd(this,appToScan);

        //ajouter des infos de l'application scannées à firestore (BDD cloud)
        ApplisHelper.createAppli(appToScan.getPackageName(), appToScan.getLabel(), appToScan.getSignature(), appToScan.isMalware())
        .addOnFailureListener(onFailureListener(this));

    }

    //pendant l'exécution de la tache
    @Override
    public String doInBackground() {
        return null;
    }

    @Override
    //permet de relier le menu a la toolbar
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.scanner_activity_menu, menu);

        MenuItem searchItem = menu.findItem(R.id.activity_scanner_item_search);
        SearchView searchView = (SearchView) searchItem.getActionView();

        searchView.setIconifiedByDefault(false);
        searchView.requestFocus();

        searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
            @Override
            public boolean onQueryTextSubmit(String query) {
                return false;
            }

            @Override
            public boolean onQueryTextChange(String newText) {
                adapter.getFilter().filter(newText);
                return false;
            }
        });

        return true;
    }

    //extraire les infos packages des applications installées
    private ArrayList<Appli> getInstalledApplication() {
        ArrayList<Appli> listeApplis = new ArrayList<Appli>();

        //recource pour extraire les infos sur les application installées
        PackageManager packageManager = this.getPackageManager();

        //extraire les application installées
        List<PackageInfo> pi = packageManager.getInstalledPackages(packageManager.GET_PERMISSIONS);//flag pour permettre extraction de permission de lappli selectionnée

        //filtrer les applications système
        for (PackageInfo packageInfo : pi) {
            Appli app;
            //si l'application ne contient pas de intent de lancement alors c'est une application système
            if (packageManager.getLaunchIntentForPackage(packageInfo.packageName) != null) {
                //sauvegarder nom de package
                String packageName = packageInfo.packageName;
                String appLabel = null;
                Drawable appIcone = null;

                try {
                    //extraire label de l'application
                    ApplicationInfo appInfo = packageManager.getApplicationInfo(packageName, packageManager.GET_META_DATA);
                    appLabel = (String) packageManager.getApplicationLabel(appInfo);

                    //extraire icone de l'application
                    appIcone = packageManager.getApplicationIcon(packageInfo.packageName); //get l'icon de l'application

                } catch (Exception e) {
                    e.printStackTrace();
                }

                //creer objet Appli
                app = new Appli(appLabel, packageName);
                app.setIcone(appIcone);

                //ajouter a la liste des applis
                listeApplis.add(app);
            }
        }
        //enregistrer le nombre d'applications installées dans le téléphone
        getSharedPreferences(PREF_FILE_NAME, MODE_PRIVATE).edit().putInt("application_installed", listeApplis.size()).apply();

        return listeApplis;
    }

    private void configureRecyclerView() {
        //preparer les PackagesInfos
        ArrayList<Appli> listeAppli = this.getInstalledApplication();

        //instancier l'adapter
        this.adapter = new ScannerAdapter(listeAppli);

        //relier l'adapter au RecyclerView
        this.mRecyclerView.setAdapter(adapter);

        //relier layout manager au RecyclerView (standard code from StackOverflow)
        this.mRecyclerView.setLayoutManager(new LinearLayoutManager(this));
    }


    //Configurer item click on RecyclerView pour gerer les cliques
    private void configureOnClickRecyclerView() {
        ItemClickSupport.addTo(mRecyclerView, R.layout.activity_scanner_item)
                .setOnItemClickListener(new ItemClickSupport.OnItemClickListener() {
                    @Override
                    public void onItemClicked(RecyclerView recyclerView, int position, View v) {
                        //recupérer l'application sélectionnée
                        appToScan = adapter.getAppli(position);

                        //recuperer les permission de l'application sélectionnée
                        appToScan.setPermissionsPropres(getAppPermissions(appToScan.getPackageName()));

                        //construire la signature de l'application
                        appSignature = SignatureBuilder.getInstance().buildAppSignature(appToScan);
                        appToScan.setSignature(appSignature);

                        //si connexion internet est disponible
                        if (isNetworkAvailable(ScannerActivity.this)) {
                            //construire le JSON a envoyer a l'API
                            String jsonString = "{\"permissions\":\"" + appToScan.getSignature() + "\"}";

                            //lancer la requete vers l'API du modèle de prediction
                            new PredictionAsyncTask(ScannerActivity.this).execute(PREDICTION_API_URL, jsonString);
                        } else {
                            Toast.makeText(ScannerActivity.this, "Pas de connexion internet", Toast.LENGTH_SHORT).show();
                        }
                    }
                });
    }

    // obtenir lespermissions d'une application
    private ArrayList<String> getAppPermissions(String packageName) {
        ArrayList<String> permissionsListe = new ArrayList<String>();
        try {
            PackageInfo packageInfo = packageManager.getPackageInfo(packageName, packageManager.GET_PERMISSIONS);
            String[] permissions = packageInfo.requestedPermissions;
            for (int i = 0; i < permissions.length; i++) {
                permissionsListe.add(permissions[i]);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return permissionsListe;
    }


    //methode de sauvegarde dans base BDD
    public static void sauvegarderAppliBdd(Context context,Appli appli) {

        //convertir l'icone
        appli.drawableToByte();

        //sauvegarder dans BDD
        MalwareCheckerDatabase.getInstance(context).appliDao().insertAppli(appli);
    }

    //méthode qui verifie la disponibilité d'une connexion internet
    public static boolean isNetworkAvailable(Context context) {
        ConnectivityManager connectivityManager
                = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
    }

    //pour verifier si l'accès à firestore est fonctionnel
    public static OnFailureListener onFailureListener(Context context) {
        return new OnFailureListener() {
            @Override
            public void onFailure(@NonNull Exception e) {
                Toast.makeText(context.getApplicationContext(), "error"+e.getMessage(), Toast.LENGTH_LONG).show();
            }
        };
    }

    public void showPopup(Context context,Appli appli){


        View dialogView = getLayoutInflater().inflate(R.layout.custom_popup,null);

        ImageView popAppIcon = (ImageView)dialogView.findViewById(R.id.custom_popup_app_icone);
        TextView popAppName = (TextView)dialogView.findViewById(R.id.custom_popup_app_name);
        TextView popAppResult = (TextView)dialogView.findViewById(R.id.custom_popup_scan_result);
        TextView popAppResultMsg = (TextView)dialogView.findViewById(R.id.custom_popup_scan_result_msg);
        LinearLayout popLayout = (LinearLayout)dialogView.findViewById(R.id.custom_popup_layout_scan_popup);


        Glide.with(context)
                .load(appli.getIcone())
                .circleCrop()
                .into(popAppIcon);

        popAppName.setText(appli.getLabel());
        if(appli.isMalware())
        {
            popAppResult.setText(R.string.popup_scan_result_malware);
            popAppResultMsg.setText(R.string.popup_scan_result_malware_msg);
            popLayout.setBackgroundColor(context.getResources().getColor(R.color.malwareRed));
        }
        else
        {
            popAppResult.setText(R.string.popup_scan_result_goodware);
            popAppResultMsg.setText(R.string.popup_scan_result_goodware_msg);
            popLayout.setBackgroundColor(context.getResources().getColor(R.color.goodwareGreen));
        }

        Dialog myDialog = new Dialog(this,R.style.dialogstyle);
        myDialog.setContentView(dialogView);
        myDialog.setCancelable(true);

        myDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
        myDialog.show();

        myDialog.setCancelable(false);

    }


}